// Code generated by protoc-gen-go.
// source: speechdata.proto
// DO NOT EDIT!

/*
Package speechdata is a generated protocol buffer package.

It is generated from these files:
	speechdata.proto

It has these top-level messages:
	RecordRequest
	StreamingConfig
	RecordSummary
*/
package speechdata

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RecordRequest struct {
	// Types that are valid to be assigned to StreamingRequest:
	//	*RecordRequest_StreamingConfig
	//	*RecordRequest_AudioContent
	StreamingRequest isRecordRequest_StreamingRequest `protobuf_oneof:"streaming_request"`
}

func (m *RecordRequest) Reset()                    { *m = RecordRequest{} }
func (m *RecordRequest) String() string            { return proto.CompactTextString(m) }
func (*RecordRequest) ProtoMessage()               {}
func (*RecordRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isRecordRequest_StreamingRequest interface {
	isRecordRequest_StreamingRequest()
}

type RecordRequest_StreamingConfig struct {
	StreamingConfig *StreamingConfig `protobuf:"bytes,1,opt,name=streaming_config,json=streamingConfig,oneof"`
}
type RecordRequest_AudioContent struct {
	AudioContent []byte `protobuf:"bytes,2,opt,name=audio_content,json=audioContent,proto3,oneof"`
}

func (*RecordRequest_StreamingConfig) isRecordRequest_StreamingRequest() {}
func (*RecordRequest_AudioContent) isRecordRequest_StreamingRequest()    {}

func (m *RecordRequest) GetStreamingRequest() isRecordRequest_StreamingRequest {
	if m != nil {
		return m.StreamingRequest
	}
	return nil
}

func (m *RecordRequest) GetStreamingConfig() *StreamingConfig {
	if x, ok := m.GetStreamingRequest().(*RecordRequest_StreamingConfig); ok {
		return x.StreamingConfig
	}
	return nil
}

func (m *RecordRequest) GetAudioContent() []byte {
	if x, ok := m.GetStreamingRequest().(*RecordRequest_AudioContent); ok {
		return x.AudioContent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RecordRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RecordRequest_OneofMarshaler, _RecordRequest_OneofUnmarshaler, _RecordRequest_OneofSizer, []interface{}{
		(*RecordRequest_StreamingConfig)(nil),
		(*RecordRequest_AudioContent)(nil),
	}
}

func _RecordRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RecordRequest)
	// streaming_request
	switch x := m.StreamingRequest.(type) {
	case *RecordRequest_StreamingConfig:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamingConfig); err != nil {
			return err
		}
	case *RecordRequest_AudioContent:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.AudioContent)
	case nil:
	default:
		return fmt.Errorf("RecordRequest.StreamingRequest has unexpected type %T", x)
	}
	return nil
}

func _RecordRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RecordRequest)
	switch tag {
	case 1: // streaming_request.streaming_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamingConfig)
		err := b.DecodeMessage(msg)
		m.StreamingRequest = &RecordRequest_StreamingConfig{msg}
		return true, err
	case 2: // streaming_request.audio_content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.StreamingRequest = &RecordRequest_AudioContent{x}
		return true, err
	default:
		return false, nil
	}
}

func _RecordRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RecordRequest)
	// streaming_request
	switch x := m.StreamingRequest.(type) {
	case *RecordRequest_StreamingConfig:
		s := proto.Size(x.StreamingConfig)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RecordRequest_AudioContent:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.AudioContent)))
		n += len(x.AudioContent)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StreamingConfig struct {
	Tok string `protobuf:"bytes,1,opt,name=tok" json:"tok,omitempty"`
	Key string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
}

func (m *StreamingConfig) Reset()                    { *m = StreamingConfig{} }
func (m *StreamingConfig) String() string            { return proto.CompactTextString(m) }
func (*StreamingConfig) ProtoMessage()               {}
func (*StreamingConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type RecordSummary struct {
	Hyp string `protobuf:"bytes,1,opt,name=hyp" json:"hyp,omitempty"`
	Err string `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
}

func (m *RecordSummary) Reset()                    { *m = RecordSummary{} }
func (m *RecordSummary) String() string            { return proto.CompactTextString(m) }
func (*RecordSummary) ProtoMessage()               {}
func (*RecordSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func init() {
	proto.RegisterType((*RecordRequest)(nil), "speechdata.RecordRequest")
	proto.RegisterType((*StreamingConfig)(nil), "speechdata.StreamingConfig")
	proto.RegisterType((*RecordSummary)(nil), "speechdata.RecordSummary")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for SpeechData service

type SpeechDataClient interface {
	// A client-to-server streaming RPC.
	//
	RecordSpeech(ctx context.Context, opts ...grpc.CallOption) (SpeechData_RecordSpeechClient, error)
}

type speechDataClient struct {
	cc *grpc.ClientConn
}

func NewSpeechDataClient(cc *grpc.ClientConn) SpeechDataClient {
	return &speechDataClient{cc}
}

func (c *speechDataClient) RecordSpeech(ctx context.Context, opts ...grpc.CallOption) (SpeechData_RecordSpeechClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SpeechData_serviceDesc.Streams[0], c.cc, "/speechdata.SpeechData/RecordSpeech", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechDataRecordSpeechClient{stream}
	return x, nil
}

type SpeechData_RecordSpeechClient interface {
	Send(*RecordRequest) error
	CloseAndRecv() (*RecordSummary, error)
	grpc.ClientStream
}

type speechDataRecordSpeechClient struct {
	grpc.ClientStream
}

func (x *speechDataRecordSpeechClient) Send(m *RecordRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *speechDataRecordSpeechClient) CloseAndRecv() (*RecordSummary, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RecordSummary)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SpeechData service

type SpeechDataServer interface {
	// A client-to-server streaming RPC.
	//
	RecordSpeech(SpeechData_RecordSpeechServer) error
}

func RegisterSpeechDataServer(s *grpc.Server, srv SpeechDataServer) {
	s.RegisterService(&_SpeechData_serviceDesc, srv)
}

func _SpeechData_RecordSpeech_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SpeechDataServer).RecordSpeech(&speechDataRecordSpeechServer{stream})
}

type SpeechData_RecordSpeechServer interface {
	SendAndClose(*RecordSummary) error
	Recv() (*RecordRequest, error)
	grpc.ServerStream
}

type speechDataRecordSpeechServer struct {
	grpc.ServerStream
}

func (x *speechDataRecordSpeechServer) SendAndClose(m *RecordSummary) error {
	return x.ServerStream.SendMsg(m)
}

func (x *speechDataRecordSpeechServer) Recv() (*RecordRequest, error) {
	m := new(RecordRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SpeechData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "speechdata.SpeechData",
	HandlerType: (*SpeechDataServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RecordSpeech",
			Handler:       _SpeechData_RecordSpeech_Handler,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("speechdata.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 274 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x51, 0x3d, 0x4f, 0xc3, 0x30,
	0x10, 0xad, 0x8b, 0x84, 0xe0, 0x48, 0x95, 0x62, 0x96, 0x02, 0x0b, 0x0a, 0x4b, 0x59, 0x32, 0xb4,
	0x42, 0x62, 0x4e, 0x19, 0x3a, 0x56, 0x89, 0xc4, 0x8a, 0x4c, 0x62, 0xda, 0xa8, 0x4a, 0x6c, 0xfc,
	0x31, 0xe4, 0xa7, 0xf0, 0x6f, 0x39, 0xbb, 0x89, 0x92, 0xa0, 0x6e, 0xa7, 0x77, 0xef, 0xc3, 0xcf,
	0x07, 0x73, 0x2d, 0x39, 0xcf, 0x0f, 0x05, 0x33, 0x2c, 0x96, 0x4a, 0x18, 0x41, 0xa1, 0x47, 0xa2,
	0x5f, 0x02, 0xb3, 0x94, 0xe7, 0x42, 0x15, 0x29, 0xff, 0xb1, 0x5c, 0x1b, 0xba, 0x45, 0x85, 0x51,
	0x9c, 0x55, 0x65, 0xbd, 0xff, 0xcc, 0x45, 0xfd, 0x5d, 0xee, 0x17, 0xe4, 0x89, 0x2c, 0x6f, 0x56,
	0x8f, 0xf1, 0xc0, 0x2a, 0xeb, 0x38, 0x1b, 0x4f, 0xd9, 0x4e, 0xd2, 0x50, 0x8f, 0x21, 0xfa, 0x02,
	0x33, 0x66, 0x8b, 0x52, 0x38, 0x17, 0xc3, 0x6b, 0xb3, 0x98, 0xa2, 0x4d, 0x90, 0x4c, 0xaf, 0x08,
	0xb2, 0x03, 0xbf, 0xda, 0x9c, 0x36, 0xc9, 0x1d, 0xdc, 0xf6, 0xa1, 0xea, 0xf4, 0x92, 0xe8, 0x15,
	0xc2, 0x7f, 0x29, 0x74, 0x0e, 0x17, 0x46, 0x1c, 0xfd, 0x7b, 0xae, 0x53, 0x37, 0x3a, 0xe4, 0xc8,
	0x1b, 0x6f, 0x8d, 0x08, 0x8e, 0xd1, 0xba, 0x6b, 0x94, 0xd9, 0xaa, 0x62, 0xaa, 0x71, 0x94, 0x43,
	0x23, 0x3b, 0x11, 0x8e, 0x0e, 0xe1, 0x4a, 0x75, 0x22, 0x1c, 0x57, 0x1f, 0x00, 0x99, 0x2f, 0xf7,
	0x8e, 0xe5, 0xf0, 0x0f, 0x82, 0xd6, 0xc2, 0x63, 0xf4, 0x7e, 0xd8, 0x7c, 0xf4, 0x5d, 0x0f, 0x67,
	0x56, 0x6d, 0x6e, 0x34, 0x59, 0x92, 0xe4, 0x0d, 0x9e, 0x59, 0x19, 0x33, 0x6b, 0x44, 0x2d, 0x2a,
	0x61, 0x75, 0xcb, 0x66, 0x52, 0xea, 0x81, 0x30, 0x09, 0xfb, 0xf0, 0x9d, 0xbb, 0xd1, 0x8e, 0x7c,
	0x5d, 0xfa, 0x63, 0xad, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x6d, 0x5f, 0xca, 0xf7, 0xc0, 0x01,
	0x00, 0x00,
}
